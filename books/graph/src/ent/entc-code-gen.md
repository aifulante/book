# 代码生成过程分析

## Schema抽象类型

首先需要关注俩个重要的点：Schema的抽象数据类型，Graph的抽象数据类型。这俩者分别存储了Schema的定义和Graph生成的定义。

### Schema的抽象数据类型

```go
type Schema struct {
	Name        string                 `json:"name,omitempty"`
	Config      ent.Config             `json:"config,omitempty"`
	Edges       []*Edge                `json:"edges,omitempty"`
	Fields      []*Field               `json:"fields,omitempty"`
	Indexes     []*Index               `json:"indexes,omitempty"`
	Hooks       []*Position            `json:"hooks,omitempty"`
	Policy      []*Position            `json:"policy,omitempty"`
	Annotations map[string]interface{} `json:"annotations,omitempty"`
}
```
### Graph的抽象数据类型

```go
type (
	// The Config holds the global codegen configuration to be
	// shared between all generated nodes.
	Config struct {
		// Schema 保存用户 entschema 的 Go 包路径。
		// For example, "<project>/ent/schema".
		Schema string

		// Target 定义保存生成代码的目标目录的文件路径。例如，“.projectent”。
		//
		// By default, 'ent generate ./ent/schema' uses './ent' as a
		// target directory.
		Target string

		// Package 定义了上面提到的目标目录的 Go 包路径。例如，“github.comorgprojectent”。
		//
		// By default, for schema package named "<project>/ent/schema",
		// 'ent generate' uses "<project>/ent" as a default package.
		Package string

		// Header allows users to provides an optional header signature for
		// the generated files. It defaults to the standard 'go generate'
		// format: '// Code generated by entc, DO NOT EDIT.'.
		Header string

		// Storage configuration for the codegen. Defaults to sql.
		Storage *Storage

		// IDType 指定 codegen 中 id 字段的类型。支持的类型是 string 和 int，这也是默认值。
		IDType *field.TypeInfo

		// Templates specifies a list of alternative templates to execute or
		// to override the default. If nil, the default template is used.
		//
		// Note that, additional templates are executed on the Graph object and
		// the execution output is stored in a file derived by the template name.
		Templates []*Template

		// Features defines a list of additional features to add to the codegen phase.
		// For example, the PrivacyFeature.
		Features []Feature

		// Hooks holds an optional list of Hooks to apply on the graph before/after the code-generation.
		Hooks []Hook

		// Annotations that are injected to the Config object can be accessed
		// globally in all templates. In order to access an annotation from a
		// graph template, do the following:
		//
		//	{{- with $.Annotations.GQL }}
		//		{{/* Annotation usage goes here. */}}
		//	{{- end }}
		//
		// For type templates, we access the Config field to access the global
		// annotations, and not the type-specific annotation.
		//
		//	{{- with $.Config.Annotations.GQL }}
		//		{{/* Annotation usage goes here. */}}
		//	{{- end }}
		//
		// 请注意，映射是从注释名称（例如“GQL”）到 JSON 解码对象。
		Annotations Annotations
	}

	// Graph holds the nodes/entities of the loaded graph schema. Note that, it doesn't
	// hold the edges of the graph. Instead, each Type holds the edges for other Types.
	Graph struct {
		*Config
		// Nodes are list of Go types that mapped to the types in the loaded schema.
		Nodes []*Type
		// Schemas holds the raw interfaces for the loaded schemas.
		Schemas []*load.Schema
	}
)
```

*需要注意的是：*
- Schema数据类型的实例是通过解析Schema的定义得到的。
- Graph数据类型的实例是通过处理Schema数据，以及结合内外部模板得到的。内部模板是预先内置的，外部模板是用户指定的。

## 基于模板的生成代码过程分析

大致的流程是这样的:
1. 在系统内部定义了要生成的文件的模板，模板的名称和路径等数据，内置在[]Template数组中，以在生成目标文件的时候调用。
2. 处理Schema数据。在对Schema数据经过一系列的校验、转换等操作后加载到Graph中。比如：将schema转为Graph的节点，转换节点的属性，转换节点的边，转换节点的索引等等。
3. 关键的一步，结合graph和模板，生成目标文件内容。生成的文件路径和文件内容是存在于assets数组中的。当然，在写文件之前，这些全部存在于内存中。
4. 将所有生成的文件落盘。

**生成代码的核心**是运用了text/template包来完成的

```go
//生成模板
b := bytes.NewBuffer(nil)
if err := templates.ExecuteTemplate(b, tmpl.Name, g); err != nil {
  return fmt.Errorf("execute template %q: %w", tmpl.Name, err)
}
```

